<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Viktorčiny "Stitch" šachy</title>
    <!-- Import PeerJS pro online hraní -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            /* Stitchova paleta barev */
            /* Pozadí: Modrý vesmírný gradient jako záloha */
            --bg-gradient: radial-gradient(circle at center, #2b5585 0%, #0f1c30 100%);
            
            /* Šachovnice - Havajský písek a dřevo */
            --board-border: #5d4037;
            --light-square: #fff8e1; /* Světlý písek */
            --dark-square: #8d6e63;  /* Kokosové dřevo */
            
            /* Herní indikátory */
            --highlight: rgba(100, 255, 218, 0.6); /* Stitchova tyrkysová */
            --selected: rgba(64, 196, 255, 0.7);   /* Stitchova modrá */
            --valid-move: rgba(0, 0, 20, 0.3);
            --check-color: radial-gradient(circle, #ff4081 0%, transparent 70%); /* Růžová (uši) */

            /* UI Barvy - Stitch Style */
            --text-color: #e3f2fd;
            --panel-bg: rgba(13, 71, 161, 0.4); /* Průhledná tmavě modrá */
            --panel-border: rgba(64, 196, 255, 0.3);
            
            --accent: #00b0ff; /* Jasná modrá */
            --danger: #f50057; /* Růžová/Červená */
            --secondary: #5c6bc0; /* Indigová */
            --blue: #448aff;
            
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            --radius: 20px; /* Více zaoblené rohy */
        }

        body {
            /* Hravější font */
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-gradient);
            /* Stitch Wallpaper */
            background-image: url('https://wallpaperaccess.com/full/213606.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-blend-mode: overlay;
            
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overflow-y: auto;
        }

        h1 { 
            margin: 15px 0 10px 0; 
            font-size: 2.2rem; 
            text-align: center; 
            font-weight: bold;
            color: #82b1ff;
            text-shadow: 2px 2px 0px #0d47a1, 0 0 10px #40c4ff;
            letter-spacing: 2px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 600px;
            padding: 10px;
            padding-bottom: 50px;
            box-sizing: border-box;
        }

        /* --- UI Components --- */
        
        .glass-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 2px solid var(--panel-border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }

        .settings {
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            padding: 15px 20px;
            width: 100%;
            box-sizing: border-box;
            font-weight: bold;
        }
        
        select, input {
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid #82b1ff;
            background: rgba(13, 71, 161, 0.6);
            color: white;
            font-family: inherit;
            outline: none;
            font-weight: bold;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 15px 25px;
            box-sizing: border-box;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 40%;
            transition: all 0.3s ease;
            opacity: 0.7;
        }

        .player-info.active-turn {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .player-name {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            color: #80d8ff;
            text-shadow: 0 0 5px #0091ea;
        }

        .timer {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            padding: 5px 12px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 2px solid #2962ff;
            min-width: 90px;
            text-align: center;
            box-shadow: 0 0 10px rgba(41, 98, 255, 0.3);
        }

        .active-turn .timer {
            border-color: #00e5ff;
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.6);
            color: #e0f7fa;
        }

        /* --- Šachovnice --- */

        .board-wrapper {
            position: relative;
            width: min(92vw, 55vh);
            height: min(92vw, 55vh); 
            aspect-ratio: 1 / 1;
            margin: 10px auto;
            border-radius: 8px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.6), 0 0 20px rgba(64, 196, 255, 0.2);
            z-index: 0; 
        }

        .watermark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50%; /* Zmenšeno na 4x4 pole (4/8 = 50%) */
            height: 50%;
            /* ZDE SE NAČÍTÁ VÁŠ OBRÁZEK */
            background-image: url('stitch_vodoznak.png'), url('https://img.icons8.com/ios/500/stitch.png'); 
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.35; /* Zvýšeno pro lepší viditelnost čar */
            pointer-events: none; 
            z-index: 1; 
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.5)); /* Jemná záře pro lepší kontrast na tmavém */
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
            border: 8px solid var(--board-border);
            border-radius: 8px;
            box-sizing: border-box;
            background: var(--board-border);
            position: relative;
            z-index: 0;
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(min(92vw, 55vh) / 9); 
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .square.light { background-color: var(--light-square); color: black; }
        .square.dark { background-color: var(--dark-square); color: black; }
        
        .piece {
            z-index: 2; 
            pointer-events: none;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1;
            filter: drop-shadow(2px 3px 2px rgba(0,0,0,0.5));
            position: relative;
        }
        .piece.white { color: #fff; text-shadow: 0 0 2px #000; }
        .piece.black { color: #212121; text-shadow: 0 0 2px #fff; }

        .square.selected { background-color: var(--selected) !important; }
        .square.last-move { background-color: var(--highlight) !important; }
        .square.check { background: var(--check-color); }
        
        .hint-dot {
            position: absolute;
            width: 20%;
            height: 20%;
            background-color: rgba(13, 71, 161, 0.4);
            border-radius: 50%;
            z-index: 1;
        }
        
        .square.capture-hint::after {
            content: '';
            position: absolute;
            width: 85%;
            height: 85%;
            border: 5px solid rgba(255, 64, 129, 0.5);
            border-radius: 50%;
            box-sizing: border-box;
            z-index: 1;
        }

        /* --- Ovládání --- */

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            margin-top: 10px;
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.2s;
            color: white;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            font-family: inherit;
        }

        button:active { transform: scale(0.95); }
        button:hover { 
            filter: brightness(1.2); 
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            transform: translateY(-2px);
        }
        
        .btn-primary { background: linear-gradient(135deg, #00b0ff, #2979ff); }
        .btn-danger { background: linear-gradient(135deg, #ff4081, #f50057); }
        .btn-secondary { background: linear-gradient(135deg, #78909c, #455a64); }
        .btn-online { background: linear-gradient(135deg, #00e676, #00c853); }

        /* --- Modals --- */

        .online-status {
            font-size: 0.9rem;
            font-weight: bold;
            color: #84ffff;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(132, 255, 255, 0.5);
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 15px;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 25, 50, 0.85);
            backdrop-filter: blur(8px);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            padding: 30px;
            text-align: center;
            max-width: 90%;
            width: 350px;
        }
        
        .modal-content h2 { margin-top: 0; color: #40c4ff; text-shadow: 0 0 10px rgba(64,196,255,0.5); }

        .promotion-options {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
        }

        .promo-piece {
            font-size: 3rem;
            cursor: pointer;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            transition: transform 0.2s, background 0.2s;
            border: 2px solid transparent;
        }
        .promo-piece:hover { 
            background: rgba(64, 196, 255, 0.2); 
            transform: translateY(-5px) rotate(5deg); 
            border-color: #40c4ff;
        }

        .id-display {
            font-family: 'Monaco', monospace;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 15px;
            color: #84ffff;
            margin: 15px 0;
            user-select: text;
            font-size: 1.2rem;
            border: 2px dashed #40c4ff;
        }

        @keyframes pulse {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }

        @media (min-width: 600px) {
            .board-wrapper { width: 500px; height: 500px; }
            .square { font-size: 55px; }
            h1 { font-size: 2.5rem; }
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h1>Viktorčiny "Stitch" šachy</h1>
        
        <div class="online-status" id="onlineStatus">Offline</div>

        <div class="settings glass-panel">
            <label>Režim:
                <select id="gameMode" onchange="game.changeMode()">
                    <option value="pvp">Hráč vs Hráč (Zde)</option>
                    <option value="pva" selected>Hráč vs AI</option>
                    <option value="online">Hráč vs Hráč (Online)</option>
                </select>
            </label>
            <label>Čas:
                <input type="number" id="timeControl" value="10" min="1" max="60" style="width: 45px; text-align: center;"> min
            </label>
        </div>

        <div class="status-bar glass-panel">
            <div class="player-info" id="black-info">
                <span class="player-name">Černý</span>
                <div class="timer" id="timer-b">10:00</div>
            </div>
            <div style="font-weight: 900; font-size: 1.2rem; color: rgba(255,255,255,0.4);">VS</div>
            <div class="player-info active-turn" id="white-info">
                <span class="player-name">Bílý</span>
                <div class="timer" id="timer-w">10:00</div>
            </div>
        </div>
        
        <div id="statusText" style="color: #b3e5fc; font-style: italic; min-height: 24px; text-align: center; margin: 5px 0; font-size: 1rem; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">
            Na tahu je bílý
        </div>

        <div class="board-wrapper">
            <!-- Watermark pod figurkami ale nad pozadím -->
            <div class="watermark"></div>
            <div class="board" id="board">
                <!-- Board generated by JS -->
            </div>
        </div>

        <div class="controls">
            <!-- Aktualizované tlačítko pro Novou hru s voláním hlasu -->
            <button class="btn-primary" onclick="game.startNewGame(false, true)">Nová hra</button>
            <button class="btn-secondary" onclick="game.undoMove()">Zpět</button>
            <button class="btn-online" id="btnOnline" style="display:none" onclick="onlineManager.showMenu()">Online</button>
        </div>
    </div>

    <!-- Modals -->
    <div id="promotionModal" class="modal">
        <div class="modal-content glass-panel">
            <h2>Proměna pěšce</h2>
            <p>Vyberte novou figuru:</p>
            <div class="promotion-options" id="promoOptions"></div>
        </div>
    </div>

    <div id="onlineModal" class="modal">
        <div class="modal-content glass-panel">
            <h2>Online Hra</h2>
            <div id="onlineMenuInitial">
                <button class="btn-primary" style="width: 100%; margin-bottom: 10px;" onclick="onlineManager.hostGame()">Založit hru (Bílý)</button>
                <div style="margin: 15px 0; font-size: 0.9rem; opacity: 0.7;">— NEBO —</div>
                <input type="text" id="joinInput" placeholder="Zadejte kód soupeře" style="width: 80%; text-align: center; margin-bottom: 10px; font-size: 1rem; padding: 10px;">
                <button class="btn-online" style="width: 100%;" onclick="onlineManager.joinGame()">Připojit se (Černý)</button>
            </div>
            <div id="onlineMenuHost" style="display:none">
                <p>Pošlete tento kód kamarádovi:</p>
                <div class="id-display" id="myIdDisplay">Generuji...</div>
                <div style="font-size: 0.9rem; color: #80d8ff; margin-top: 10px;">
                    <span style="display: inline-block; animation: pulse 1.5s infinite; color: #ff4081;">●</span> Čekám na soupeře...
                </div>
            </div>
            <br>
            <button class="btn-secondary" style="margin-top: 10px;" onclick="document.getElementById('onlineModal').style.display='none'">Zavřít</button>
        </div>
    </div>

<script>
/**
 * Šachová Logika & AI & Online
 */

const PIECES = {
    w: { k: '♔', q: '♕', r: '♖', b: '♗', n: '♘', p: '♙' },
    b: { k: '♚', q: '♛', r: '♜', b: '♝', n: '♞', p: '♟' }
};

const PIECE_VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };

/* Upravený SoundFX pro Stitch zvuky a Mluvení */
const SoundFX = {
    ctx: null,
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    // Vylepšená funkce pro tóny s klouzáním frekvence (slide)
    playTone: function(freq, type, duration, slideTo = null, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        // Efekt klouzání tónu (typické pro sci-fi/kreslené zvuky)
        if (slideTo) {
            osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
        }

        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    // Hlasová syntéza (Mluvení)
    speak: function(text) {
        if ('speechSynthesis' in window) {
            // Zrušit předchozí, pokud mluví
            window.speechSynthesis.cancel();
            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = 'cs-CZ';
            utter.rate = 0.9; // Trochu pomalejší pro lepší srozumitelnost
            window.speechSynthesis.speak(utter);
        }
    },
    // Tah: Mimozemské cvrliknutí (jako Stitchova řeč)
    move: function() { 
        this.init(); 
        // Sine vlna co jde rychle nahoru
        this.playTone(400, 'sine', 0.15, 800, 0.1); 
    },
    // Braní: Křupnutí/Kousnutí (vrčivý zvuk)
    capture: function() { 
        this.init(); 
        // Sawtooth vlna co jde rychle dolů
        this.playTone(150, 'sawtooth', 0.2, 50, 0.15); 
    },
    // Šach: "Uh-oh" (klesající dvojtón)
    check: function() { 
        this.init(); 
        this.playTone(500, 'triangle', 0.15, null, 0.2); 
        setTimeout(() => {
            this.playTone(350, 'triangle', 0.4, 300, 0.2);
        }, 150);
    }
};

class OnlineManager {
    constructor() {
        this.peer = null;
        this.conn = null;
        this.myId = null;
        this.isHost = false;
    }

    showMenu() {
        document.getElementById('onlineModal').style.display = 'flex';
        document.getElementById('onlineMenuInitial').style.display = 'block';
        document.getElementById('onlineMenuHost').style.display = 'none';
    }

    generateId() {
        return 'sachy-' + Math.floor(Math.random() * 9000 + 1000);
    }

    hostGame() {
        document.getElementById('onlineMenuInitial').style.display = 'none';
        document.getElementById('onlineMenuHost').style.display = 'block';
        
        const id = this.generateId();
        this.peer = new Peer(id);
        
        this.peer.on('open', (id) => {
            this.myId = id;
            document.getElementById('myIdDisplay').innerText = id;
            this.isHost = true;
        });

        this.peer.on('connection', (conn) => {
            this.conn = conn;
            this.setupConnection();
            document.getElementById('onlineModal').style.display = 'none';
            alert("Soupeř připojen! Hrajete za Bílého.");
            game.startOnlineGame('w');
        });
        
        this.peer.on('error', (err) => {
            alert("Chyba spojení: " + err.type);
            console.error(err);
        });
    }

    joinGame() {
        const destId = document.getElementById('joinInput').value.trim();
        if(!destId) return alert("Zadejte ID");

        this.peer = new Peer(); 
        
        this.peer.on('open', () => {
            this.conn = this.peer.connect(destId);
            this.isHost = false;
            
            this.conn.on('open', () => {
                this.setupConnection();
                document.getElementById('onlineModal').style.display = 'none';
                alert("Připojeno! Hrajete za Černého.");
                game.startOnlineGame('b');
            });
            
            this.peer.on('error', (err) => {
                alert("Nepodařilo se připojit. Zkontrolujte ID.");
            });
        });
    }

    setupConnection() {
        document.getElementById('onlineStatus').innerText = "Online: Připojeno";
        document.getElementById('onlineStatus').style.color = "#00e676";
        
        this.conn.on('data', (data) => {
            if (data.type === 'move') {
                game.executeMove(data.from, data.to, data.promotion, false); 
            } else if (data.type === 'restart') {
                game.startNewGame(true);
            }
        });
        
        this.conn.on('close', () => {
            alert("Soupeř se odpojil.");
            document.getElementById('onlineStatus').innerText = "Offline";
            document.getElementById('onlineStatus').style.color = "#84ffff";
            game.mode = 'pva';
            document.getElementById('gameMode').value = 'pva';
            game.changeMode();
        });
    }

    sendMove(from, to, promotion) {
        if (this.conn && this.conn.open) {
            this.conn.send({ type: 'move', from, to, promotion });
        }
    }
    
    sendRestart() {
        if (this.conn && this.conn.open) {
            this.conn.send({ type: 'restart' });
        }
    }
}

const onlineManager = new OnlineManager();

class ChessGame {
    constructor() {
        this.board = [];
        this.turn = 'w'; 
        this.castling = { w: { k: true, q: true }, b: { k: true, q: true } };
        this.enPassantTarget = null;
        this.history = [];
        this.gameOver = false;
        
        this.whiteTime = 600;
        this.blackTime = 600;
        this.timerInterval = null;
        this.mode = 'pva';
        this.aiThinking = false;
        this.myColor = null; 

        this.initBoard();
        this.renderBoard();
        document.body.addEventListener('click', () => SoundFX.init(), { once: true });
    }

    initBoard() {
        const setup = [
            'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r',
            'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p',
            null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null,
            'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P',
            'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'
        ];
        this.board = [...setup];
    }
    
    changeMode() {
        this.mode = document.getElementById('gameMode').value;
        const btnOnline = document.getElementById('btnOnline');
        
        if (this.mode === 'online') {
            btnOnline.style.display = 'inline-block';
            onlineManager.showMenu();
        } else {
            btnOnline.style.display = 'none';
            this.myColor = null; 
            document.getElementById('onlineStatus').innerText = "Offline";
            document.getElementById('onlineStatus').style.color = "#84ffff";
            if (onlineManager.peer) {
                onlineManager.peer.destroy();
                onlineManager.peer = null;
            }
        }
    }

    startNewGame(isRemoteTrigger = false, speakQuote = false) {
        if (this.mode === 'online' && !isRemoteTrigger) {
            onlineManager.sendRestart();
        }
        
        // Přehrát citát, pokud je vyžádáno (při kliknutí na tlačítko)
        if (speakQuote) {
            SoundFX.speak("Ohana, hra začíná. Hodně štěstí ve hře.");
        }
        
        clearInterval(this.timerInterval);
        this.initBoard();
        this.turn = 'w';
        this.castling = { w: { k: true, q: true }, b: { k: true, q: true } };
        this.enPassantTarget = null;
        this.history = [];
        this.gameOver = false;
        
        const minutes = parseInt(document.getElementById('timeControl').value) || 10;
        this.whiteTime = minutes * 60;
        this.blackTime = minutes * 60;
        this.aiThinking = false;
        
        this.updateStatusUI();
        this.deselect();
        this.renderBoard();
        this.startTimer();
    }
    
    startOnlineGame(color) {
        this.myColor = color;
        this.startNewGame(true); 
        this.updateStatusUI();
    }

    startTimer() {
        if (this.timerInterval) clearInterval(this.timerInterval);
        this.timerInterval = setInterval(() => {
            if (this.gameOver) return;
            if (this.turn === 'w') {
                this.whiteTime--;
                if (this.whiteTime <= 0) this.endGame('b', 'Čas vypršel!');
            } else {
                this.blackTime--;
                if (this.blackTime <= 0) this.endGame('w', 'Čas vypršel!');
            }
            this.updateTimeUI();
        }, 1000);
        this.updateTimeUI();
    }

    updateTimeUI() {
        const fmt = (t) => {
            if (t < 0) t = 0;
            const m = Math.floor(t / 60).toString().padStart(2, '0');
            const s = (t % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        };
        document.getElementById('timer-w').textContent = fmt(this.whiteTime);
        document.getElementById('timer-b').textContent = fmt(this.blackTime);

        document.getElementById('white-info').classList.toggle('active-turn', this.turn === 'w');
        document.getElementById('black-info').classList.toggle('active-turn', this.turn === 'b');
    }

    getPieceColor(piece) {
        if (!piece) return null;
        return piece === piece.toUpperCase() ? 'w' : 'b';
    }

    getPseudoMoves(index, board = this.board) {
        const piece = board[index];
        if (!piece) return [];
        const color = this.getPieceColor(piece);
        const type = piece.toLowerCase();
        const moves = [];
        const row = Math.floor(index / 8);
        const col = index % 8;

        const addMove = (r, c) => {
            if (r < 0 || r > 7 || c < 0 || c > 7) return false;
            const targetIndex = r * 8 + c;
            const targetPiece = board[targetIndex];
            if (!targetPiece) { moves.push(targetIndex); return true; }
            else if (this.getPieceColor(targetPiece) !== color) { moves.push(targetIndex); return false; }
            return false;
        };

        if (type === 'p') {
            const dir = color === 'w' ? -1 : 1;
            const startRow = color === 'w' ? 6 : 1;
            if (!board[(row + dir) * 8 + col]) {
                moves.push((row + dir) * 8 + col);
                if (row === startRow && !board[(row + dir * 2) * 8 + col]) {
                    moves.push((row + dir * 2) * 8 + col);
                }
            }
            [[dir, -1], [dir, 1]].forEach(([dr, dc]) => {
                const tr = row + dr, tc = col + dc;
                if (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
                    const tidx = tr * 8 + tc;
                    if ((board[tidx] && this.getPieceColor(board[tidx]) !== color) || tidx === this.enPassantTarget) {
                        moves.push(tidx);
                    }
                }
            });
        } 
        else if (type === 'n') { [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr, dc]) => addMove(row + dr, col + dc)); } 
        else if (type === 'k') { [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr, dc]) => addMove(row + dr, col + dc)); } 
        else {
            const directions = [];
            if (type === 'b' || type === 'q') directions.push([1,1],[1,-1],[-1,1],[-1,-1]);
            if (type === 'r' || type === 'q') directions.push([1,0],[-1,0],[0,1],[0,-1]);
            directions.forEach(([dr, dc]) => { let r=row+dr, c=col+dc; while(addMove(r,c)) { r+=dr; c+=dc; } });
        }
        return moves;
    }

    isCheck(color, tempBoard = this.board) {
        const kingChar = color === 'w' ? 'K' : 'k';
        const kingIdx = tempBoard.indexOf(kingChar);
        if (kingIdx === -1) return true; 
        for (let i = 0; i < 64; i++) {
            const p = tempBoard[i];
            if (p && this.getPieceColor(p) !== color) {
                const moves = this.getPseudoMoves(i, tempBoard);
                if (moves.includes(kingIdx)) return true;
            }
        }
        return false;
    }

    getLegalMoves(index) {
        const piece = this.board[index];
        if (!piece || this.getPieceColor(piece) !== this.turn) return [];

        const pseudoMoves = this.getPseudoMoves(index);
        const legalMoves = [];

        pseudoMoves.forEach(to => {
            const savedBoard = [...this.board];
            if (piece.toLowerCase() === 'p' && to === this.enPassantTarget && !savedBoard[to]) {
                const capIdx = to + (this.turn === 'w' ? 8 : -8);
                savedBoard[capIdx] = null;
            }
            savedBoard[to] = savedBoard[index];
            savedBoard[index] = null;
            if (!this.isCheck(this.turn, savedBoard)) legalMoves.push(to);
        });

        if (piece.toLowerCase() === 'k' && !this.isCheck(this.turn)) {
            const row = this.turn === 'w' ? 7 : 0;
            const rights = this.castling[this.turn];
            if (rights.k && !this.board[row*8+5] && !this.board[row*8+6]) {
                if (this.isSquareSafe(row*8+5, this.turn) && this.isSquareSafe(row*8+6, this.turn)) legalMoves.push(row*8+6);
            }
            if (rights.q && !this.board[row*8+1] && !this.board[row*8+2] && !this.board[row*8+3]) {
                 if (this.isSquareSafe(row*8+3, this.turn) && this.isSquareSafe(row*8+2, this.turn)) legalMoves.push(row*8+2);
            }
        }
        return legalMoves;
    }

    isSquareSafe(index, color) {
        const enemyColor = color === 'w' ? 'b' : 'w';
        for (let i = 0; i < 64; i++) {
            const p = this.board[i];
            if (p && this.getPieceColor(p) === enemyColor) {
                if (this.getPseudoMoves(i).includes(index)) return false;
            }
        }
        return true;
    }

    makeMove(from, to, promotion = 'q') {
        const piece = this.board[from];
        const target = this.board[to];
        const moveData = { from, to, piece, target, castling: JSON.parse(JSON.stringify(this.castling)), enPassantTarget: this.enPassantTarget };

        let epCapture = false;
        if (piece.toLowerCase() === 'p' && to === this.enPassantTarget && !target) {
            const capIdx = to + (this.turn === 'w' ? 8 : -8);
            moveData.capturedEp = this.board[capIdx]; moveData.capIdx = capIdx; this.board[capIdx] = null; epCapture = true;
        }

        this.board[to] = piece; this.board[from] = null;

        if (piece.toLowerCase() === 'k' && Math.abs(to - from) === 2) {
            const row = Math.floor(from / 8);
            if (to === from + 2) { this.board[row*8+5] = this.board[row*8+7]; this.board[row*8+7] = null; } 
            else { this.board[row*8+3] = this.board[row*8+0]; this.board[row*8+0] = null; }
        }

        if (piece.toLowerCase() === 'p') {
            const destRow = Math.floor(to / 8);
            if (destRow === 0 || destRow === 7) this.board[to] = this.turn === 'w' ? promotion.toUpperCase() : promotion.toLowerCase();
        }

        if (piece === 'K') this.castling.w = { k: false, q: false };
        if (piece === 'k') this.castling.b = { k: false, q: false };
        if (piece === 'R') { if (from === 63) this.castling.w.k = false; if (from === 56) this.castling.w.q = false; }
        if (piece === 'r') { if (from === 7) this.castling.b.k = false; if (from === 0) this.castling.b.q = false; }
        if (target === 'R') { if (to === 63) this.castling.w.k = false; if (to === 56) this.castling.w.q = false; }
        if (target === 'r') { if (to === 7) this.castling.b.k = false; if (to === 0) this.castling.b.q = false; }

        this.history.push(moveData);
        this.enPassantTarget = (piece.toLowerCase() === 'p' && Math.abs(to - from) === 16) ? (from + to) / 2 : null;
        this.turn = this.turn === 'w' ? 'b' : 'w';
        
        try { if (target || epCapture) SoundFX.capture(); else SoundFX.move(); } catch(e){}
        return true;
    }

    undoMove() {
        if (this.mode === 'online') return; 
        if (this.history.length === 0 || this.gameOver) { if (this.gameOver) { this.gameOver = false; this.startTimer(); } }
        
        let movesToUndo = (this.mode === 'pva' && this.turn === 'w' && this.history.length >= 2) ? 2 : 1;
        for (let i=0; i<movesToUndo; i++) {
            if (this.history.length === 0) break;
            const last = this.history.pop();
            this.board[last.from] = last.piece; this.board[last.to] = last.target;
            if (last.capturedEp) this.board[last.capIdx] = last.capturedEp;
            if (last.piece.toLowerCase() === 'k' && Math.abs(last.to - last.from) === 2) {
                if (last.to === last.from + 2) { this.board[last.from + 7] = this.board[last.from + 5]; this.board[last.from + 5] = null; } 
                else { this.board[last.from + 0] = this.board[last.from + 3]; this.board[last.from + 3] = null; }
            }
            this.castling = last.castling; this.enPassantTarget = last.enPassantTarget;
            this.turn = this.turn === 'w' ? 'b' : 'w';
        }
        this.gameOver = false;
        this.updateStatusUI();
        this.renderBoard();
        this.deselect();
    }

    checkGameState() {
        let hasMoves = false;
        for (let i = 0; i < 64; i++) {
            if (this.getPieceColor(this.board[i]) === this.turn) {
                if (this.getLegalMoves(i).length > 0) { hasMoves = true; break; }
            }
        }

        if (!hasMoves) {
            if (this.isCheck(this.turn)) this.endGame(this.turn === 'w' ? 'b' : 'w', 'Mat!');
            else this.endGame('draw', 'Pat (Remíza)');
            return;
        }

        const pieces = this.board.filter(p => p !== null);
        if (pieces.length <= 3) {
            const types = pieces.map(p => p.toLowerCase());
            if (pieces.length === 2 || (pieces.length === 3 && (types.includes('n') || types.includes('b')))) 
                this.endGame('draw', 'Remíza (Nedostatek materiálu)');
        }
        
        if (this.isCheck(this.turn)) SoundFX.check();
        this.updateStatusUI();
        if (this.mode === 'pva' && this.turn === 'b' && !this.gameOver) setTimeout(() => this.makeAIMove(), 250);
    }

    endGame(winner, reason) {
        this.gameOver = true;
        clearInterval(this.timerInterval);
        
        // Přehrát zvuk O ou při matu
        if (reason === 'Mat!') {
            SoundFX.speak("ŠACH MAT, ZKUS TO ZNOVU");
        }

        const text = winner === 'draw' ? reason : `${reason} Vítěz: ${winner === 'w' ? 'Bílý' : 'Černý'}`;
        document.getElementById('statusText').innerText = text;
        if (winner !== 'draw') {
             const loserColor = winner === 'w' ? 'b' : 'w';
             const kIdx = this.board.indexOf(loserColor === 'w' ? 'K' : 'k');
             if(kIdx !== -1) document.querySelectorAll('.square')[kIdx].classList.add('check');
        }
        setTimeout(() => alert(text), 500); // Mírné zpoždění, aby stihlo zaznít O ou
    }

    updateStatusUI() {
        if (this.gameOver) return;
        let text = this.isCheck(this.turn) ? 'ŠACH! ' : '';
        text += (this.turn === 'w' ? 'Na tahu: Bílý' : 'Na tahu: Černý');
        if (this.mode === 'online' && this.myColor) {
            text += (this.myColor === this.turn ? ' (VY)' : ' (Soupeř)');
        }
        document.getElementById('statusText').innerText = text;
    }

    resign() {
        if (this.gameOver) return;
        this.endGame(this.turn === 'w' ? 'b' : 'w', 'Hráč se vzdal.');
    }

    // --- AI ---
    evaluateBoard() {
        let score = 0;
        for (let i = 0; i < 64; i++) {
            const piece = this.board[i];
            if (!piece) continue;
            const type = piece.toLowerCase();
            const val = PIECE_VALUES[type] || 0;
            const isWhite = piece === piece.toUpperCase();
            let posBonus = 0;
            if (type === 'p') posBonus = isWhite ? (6-Math.floor(i/8))*10 : Math.floor(i/8)*10;
            else if (type === 'n' || type === 'b') { if (Math.floor(i/8) > 2 && Math.floor(i/8) < 5 && i%8 > 2 && i%8 < 5) posBonus = 20; }
            if (isWhite) score += (val + posBonus); else score -= (val + posBonus);
        }
        return score;
    }

    makeAIMove() {
        if (this.gameOver) return;
        this.aiThinking = true;
        const bestMove = this.minimax(2, -Infinity, Infinity, false);
        if (bestMove && bestMove.from !== undefined) {
            this.executeMove(bestMove.from, bestMove.to, 'q');
        }
        this.aiThinking = false;
    }

    minimax(depth, alpha, beta, isMaximizingPlayer) {
        if (depth === 0) return { score: this.evaluateBoard() };
        const color = isMaximizingPlayer ? 'w' : 'b';
        const possibleMoves = this.getAllAllMoves(color);
        if (possibleMoves.length === 0) return { score: this.isCheck(color) ? (isMaximizingPlayer ? -Infinity : Infinity) : 0 };

        possibleMoves.sort((a, b) => {
             const valA = this.board[a.to] ? PIECE_VALUES[this.board[a.to].toLowerCase()] : 0;
             const valB = this.board[b.to] ? PIECE_VALUES[this.board[b.to].toLowerCase()] : 0;
             return valB - valA;
        });

        let bestMove = null;
        if (isMaximizingPlayer) { 
            let maxEval = -Infinity;
            for (const move of possibleMoves) {
                const saved = this.saveState(); this.makeMove(move.from, move.to, 'q');
                const evalObj = this.minimax(depth - 1, alpha, beta, false); this.restoreState(saved);
                if (evalObj.score > maxEval) { maxEval = evalObj.score; bestMove = move; }
                alpha = Math.max(alpha, evalObj.score); if (beta <= alpha) break;
            }
            return { score: maxEval, ...bestMove };
        } else { 
            let minEval = Infinity;
            for (const move of possibleMoves) {
                const saved = this.saveState(); this.makeMove(move.from, move.to, 'q');
                const evalObj = this.minimax(depth - 1, alpha, beta, true); this.restoreState(saved);
                if (evalObj.score < minEval) { minEval = evalObj.score; bestMove = move; }
                beta = Math.min(beta, evalObj.score); if (beta <= alpha) break;
            }
            return { score: minEval, ...bestMove };
        }
    }

    getAllAllMoves(color) {
        const moves = [];
        for (let i = 0; i < 64; i++) {
            if (this.board[i] && this.getPieceColor(this.board[i]) === color) {
                this.getLegalMoves(i).forEach(to => moves.push({ from: i, to }));
            }
        }
        return moves;
    }

    saveState() {
        return { board: [...this.board], turn: this.turn, castling: JSON.parse(JSON.stringify(this.castling)), enPassantTarget: this.enPassantTarget, gameOver: this.gameOver, history: [...this.history] };
    }
    restoreState(state) {
        this.board = state.board; this.turn = state.turn; this.castling = state.castling; this.enPassantTarget = state.enPassantTarget; this.gameOver = state.gameOver; this.history = state.history;
    }

    // --- UI ---
    renderBoard() {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';
        let lastMoveFrom = -1, lastMoveTo = -1;
        if (this.history.length > 0) { const last = this.history[this.history.length-1]; lastMoveFrom = last.from; lastMoveTo = last.to; }

        this.board.forEach((piece, index) => {
            const square = document.createElement('div');
            const row = Math.floor(index / 8);
            const col = index % 8;
            square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
            if (index === lastMoveFrom || index === lastMoveTo) square.classList.add('last-move');
            square.dataset.index = index;
            square.onclick = () => this.handleSquareClick(index);

            if (piece) {
                const pDiv = document.createElement('div');
                pDiv.className = `piece ${this.getPieceColor(piece) === 'w' ? 'white' : 'black'}`;
                pDiv.textContent = PIECES[this.getPieceColor(piece)][piece.toLowerCase()];
                square.appendChild(pDiv);
                if (piece.toLowerCase() === 'k' && this.isCheck(this.getPieceColor(piece))) square.classList.add('check');
            }
            boardEl.appendChild(square);
        });
        
        if (this.selectedSquare !== null) {
            const squares = boardEl.children;
            squares[this.selectedSquare].classList.add('selected');
            this.possibleMoves.forEach(m => {
                const isCapture = this.board[m] !== null || (m === this.enPassantTarget && this.board[this.selectedSquare].toLowerCase() === 'p');
                if (isCapture) squares[m].classList.add('capture-hint');
                else { const dot = document.createElement('div'); dot.className = 'hint-dot'; squares[m].appendChild(dot); }
            });
        }
    }
    
    selectedSquare = null; possibleMoves = [];

    handleSquareClick(index) {
        if (this.gameOver || this.aiThinking) return;
        
        if (this.mode === 'online') {
            if (!this.myColor) return; 
            if (this.turn !== this.myColor) return; 
        } else if (this.mode === 'pva' && this.turn === 'b') {
            return; 
        }

        const piece = this.board[index];
        const isOwnPiece = piece && this.getPieceColor(piece) === this.turn;

        if (isOwnPiece) { this.selectSquare(index); } 
        else if (this.selectedSquare !== null && this.possibleMoves.includes(index)) {
            const movingPiece = this.board[this.selectedSquare];
            const isPawn = movingPiece.toLowerCase() === 'p';
            const destRow = Math.floor(index / 8);
            if (isPawn && (destRow === 0 || destRow === 7)) this.showPromotionModal(this.selectedSquare, index);
            else this.executeMove(this.selectedSquare, index, 'q', true); 
        } 
        else { this.deselect(); this.renderBoard(); }
    }

    selectSquare(index) { this.selectedSquare = index; this.possibleMoves = this.getLegalMoves(index); this.renderBoard(); }
    deselect() { this.selectedSquare = null; this.possibleMoves = []; }

    executeMove(from, to, promotion = 'q', sendOnline = false) {
        this.makeMove(from, to, promotion);
        
        if (this.mode === 'online' && sendOnline) {
            onlineManager.sendMove(from, to, promotion);
        }

        this.deselect();
        this.renderBoard();
        this.checkGameState();
    }

    showPromotionModal(from, to) {
        const modal = document.getElementById('promotionModal');
        const container = document.getElementById('promoOptions');
        container.innerHTML = '';
        const pieces = ['q', 'r', 'b', 'n'];
        pieces.forEach(p => {
            const btn = document.createElement('div');
            btn.className = 'promo-piece';
            btn.style.color = '#fff'; 
            btn.textContent = PIECES[this.turn][p];
            btn.onclick = () => {
                modal.style.display = 'none';
                this.executeMove(from, to, p, true);
            };
            container.appendChild(btn);
        });
        modal.style.display = 'flex';
    }
}

const game = new ChessGame();
game.startNewGame();

</script>
</body>
</html>